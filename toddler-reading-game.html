<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Learning Game for Toddlers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-sky: #7cc7ff;
            --bg-sun: #cfe9ff;
            --card-glass: rgba(255, 255, 255, 0.3);
            --card-border: rgba(255, 255, 255, 0.6);
            --accent-warm: #4fa3ff;
            --accent-cool: #2d7ff9;
            --text-bright: #f4fbff;
            --shadow-soft: rgba(0, 0, 0, 0.18);
        }

        body {
            font-family: 'Comic Sans MS', 'Trebuchet MS', 'Arial Rounded MT Bold', cursive, sans-serif;
            background: linear-gradient(160deg, var(--bg-sky) 0%, #a8d9ff 40%, var(--bg-sun) 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            inset: -20%;
            background:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.5), transparent 40%),
                radial-gradient(circle at 80% 15%, rgba(255, 255, 255, 0.35), transparent 45%),
                radial-gradient(circle at 70% 80%, rgba(255, 255, 255, 0.25), transparent 50%),
                radial-gradient(circle at 30% 75%, rgba(255, 255, 255, 0.3), transparent 55%);
            filter: blur(0px);
            pointer-events: none;
        }

        .container {
            text-align: center;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .word-display {
            font-size: 12vw;
            font-weight: bold;
            color: var(--text-bright);
            text-shadow: 4px 4px 10px rgba(0, 0, 0, 0.25);
            margin: 20px 0;
            padding: 40px 30px;
            background: linear-gradient(145deg, var(--card-glass), rgba(255, 255, 255, 0.15));
            border-radius: 30px;
            border: 8px solid var(--card-border);
            min-height: 260px;
            max-height: none;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s ease;
            overflow: hidden;
            box-shadow: 0 12px 24px var(--shadow-soft);
            flex: 1;
        }

        .word-display.multi-line {
            font-size: 9vw;
        }

        .word-display.very-long {
            font-size: 7.5vw;
        }

        .word-display span {
            line-height: 1.2;
            word-wrap: break-word;
            max-width: 100%;
            display: block;
        }

        .word-display.listening {
            border-color: #34d399;
            box-shadow: 0 0 16px rgba(52, 211, 153, 0.35);
        }

        .word-display.success {
            border-color: #ffe066;
            background: linear-gradient(135deg, rgba(255, 224, 102, 0.35), rgba(255, 255, 255, 0.35));
            box-shadow: 0 0 24px rgba(255, 224, 102, 0.45);
            animation: successPulse 0.3s ease;
        }

        @keyframes successPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        .character {
            position: absolute;
            bottom: -40px;
            right: 30px;
            font-size: 80px;
        }

        .character.celebrate {
            animation: celebrate 0.3s ease;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.12); }
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .record-controls {
            display: none;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .small-btn {
            font-size: 16px;
            padding: 8px 14px;
            border-radius: 12px;
        }

        .record-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #22c55e;
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
        }

        .record-dot.recording {
            background: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
        }

        .download-link {
            font-size: 14px;
            color: #ffffff;
            text-decoration: underline;
            cursor: pointer;
        }

        button {
            font-size: 20px;
            padding: 12px 24px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, var(--accent-cool) 0%, var(--accent-warm) 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
            transition: transform 0.15s;
            font-family: inherit;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .status {
            font-size: 22px;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.12);
            padding: 10px 16px;
            border-radius: 999px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
        }

        .confetti {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .feedback-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: bold;
            color: #1f2a44;
            text-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            background: linear-gradient(135deg, rgba(255, 247, 210, 0.98), rgba(255, 255, 255, 0.95));
            padding: 18px 28px;
            border-radius: 28px;
            border: 4px solid rgba(255, 193, 71, 0.85);
            box-shadow: 0 12px 22px rgba(0, 0, 0, 0.18);
        }

        .feedback-message.show {
            animation: feedbackPop 0.7s ease;
        }

        @keyframes feedbackPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            40% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        .mic-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #4ade80;
            border-radius: 50%;
            margin-left: 10px;
        }

        .level-indicator {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.4);
        }

        .progress-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.95);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .footer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .word-display {
                font-size: 10vw;
                padding: 20px 15px;
                min-height: 150px;
            }

            .status {
                font-size: 18px;
            }

            button {
                font-size: 18px;
                padding: 10px 20px;
            }

            .character {
                font-size: 60px;
                bottom: -40px;
                right: 20px;
            }
        }

        /* For very small screens or long phrases */
        @media (max-height: 700px) {
            .word-display {
                font-size: 8vw;
                min-height: 160px;
                max-height: none;
            }

            .word-display.multi-line {
                font-size: 7vw;
            }

            .word-display.very-long {
                font-size: 6vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="level-indicator" id="levelIndicator" style="display: none;">
                <span class="level-badge">Level <span id="levelNumber">1</span></span>
            </div>
            <div class="progress-text" id="progressText"></div>
        </div>

        <div class="word-display" id="wordDisplay">
            <span id="currentWord">Ready!</span>
            <div class="character" id="character">ü¶Å</div>
        </div>

        <div class="footer">
            <div class="controls">
                <button id="startBtn" onclick="startGame(false)">Start</button>
                <button id="startRecordBtn" onclick="startGame(true)">Start with Recording</button>
                <button id="skipBtn" onclick="skipWord()" style="display: none;">Skip Word</button>
                <button id="restartBtn" onclick="restartGame()" style="display: none;">Play Again</button>
            </div>
            <div class="record-controls">
                <span class="record-dot" id="recordDot" aria-label="Recording status"></span>
                <button class="small-btn" id="stopRecordBtn" onclick="stopRecording()" disabled>Stop</button>
                <a class="download-link" id="downloadLink" style="display: none;" download="toddler-recording.webm">Download</a>
            </div>
        </div>
    </div>

    <canvas class="confetti" id="confetti"></canvas>
    <div class="feedback-message" id="feedbackMessage"></div>

    <script>
        // Expanded word list with more granular difficulty levels
        const wordLevels = [
            // Level 0: Very simple 3-letter words
            ['cat', 'dog', 'sun', 'hat', 'cup', 'pen'],
            // Level 1: More 3-letter words
            ['run', 'top', 'car', 'bus', 'bed', 'egg'],
            // Level 2: Easy 4-letter words
            ['ball', 'tree', 'book', 'duck', 'fish', 'star'],
            // Level 3: More 4-letter words
            ['jump', 'play', 'bird', 'frog', 'moon', 'wind'],
            // Level 4: 5-letter words
            ['house', 'happy', 'water', 'apple', 'smile', 'table'],
            // Level 5: More 5-letter words
            ['horse', 'green', 'light', 'chair', 'plant', 'heart'],
            // Level 6: Simple 2-word phrases
            ['big cat', 'red ball', 'blue sky', 'my dog', 'the sun', 'fun game'],
            // Level 7: More 2-word phrases
            ['happy kid', 'green frog', 'yellow star', 'fast car', 'soft bed', 'warm hug'],
            // Level 8: 3-word phrases
            ['I love you', 'big red ball', 'the sun shines', 'happy little dog', 'blue and green', 'jump and play'],
            // Level 9: Longer phrases
            [
                'look at me',
                'I did it',
                'all done',
                'more please',
                'help me please',
                'I need help',
                'I am hungry',
                'I am thirsty',
                'I need a drink',
                'I want milk',
                'I want water',
                'I want snack',
                'time to eat',
                'wash hands',
                'brush teeth',
                'time for bed',
                'good morning',
                'good night',
                'I need potty',
                'time to potty',
                'diaper change',
                'hold my hand',
                'where is mom',
                'where is dad',
                'where is home',
                'I feel happy',
                'I feel sad',
                'I feel scared',
                'I feel sleepy',
                'I am tired',
                'I need a hug',
                'that hurts',
                'please stop',
                'my turn',
                'your turn',
                'can I play',
                'share please',
                'wait for me',
                'I want that',
                'I like this',
                'I do not like that',
                'read a book',
                'sing a song',
                'play with me',
                'let us play',
                'this is fun',
                'you are great',
                'good job',
                'well done',
                'I can read',
                'I love you',
                'I love mommy',
                'I love daddy',
                'I love my family',
                'you are my friend',
                'we can play together',
                'jump and play',
                'jump up high',
                'clap your hands',
                'stomp your feet',
                'spin around',
                'lets go outside',
                'lets go home',
                'lets have a snack',
                'more water please',
                'I want juice',
                'thank you',
                'thank you mom',
                'thank you dad',
                'please and thank you',
                'nice to meet you',
                'I am brave',
                'I am kind',
                'I am gentle',
                'I can share',
                'lets clean up',
                'clean up toys',
                'put toys away',
                'wash your face',
                'take a bath',
                'time for bath',
                'put on shoes',
                'put on socks',
                'I want my blanket',
                'I want my teddy',
                'where is my toy',
                'look at the cat',
                'look at the dog',
                'I see a bus',
                'I see a car',
                'I see a truck',
                'open the door',
                'close the door',
                'turn on light',
                'turn off light',
                'please sit down',
                'please stand up',
                'lets go potty',
                'time to wash up',
                'dry your hands',
                'count to ten',
                'big red ball',
                'the sun shines',
                'happy little dog',
                'blue and green'
            ]
        ];

        let currentLevel = 0;
        let currentWordIndex = 0;
        let currentWords = [];
        let score = 0;
        let recognition = null;
        let isListening = false;
        let lastRecognitionTime = 0;
        let recognitionDebounceTimer = null;
        let isProcessingWord = false;  // Prevent double-matches during celebration
        let manualRestartPending = false;  // Avoid double restarts when re-arming per word
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStream = null;
        let downloadUrl = null;
        let pendingRecordingStart = false;
        let isRecordingActive = false;

        // Adaptive difficulty tracking
        let consecutiveSuccesses = 0;
        let consecutiveFailures = 0;
        const SUCCESS_THRESHOLD = 4;  // Level up after 4 successes
        const FAILURE_THRESHOLD = 3;  // Level down after 3 skips/struggles

        // Debug tracking
        let debugAttempts = [];

        // Audio context for sounds
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Character emojis that rotate
        const characters = ['ü¶Å', 'üêº', 'üê®', 'ü¶ä', 'üêØ', 'üê∏', 'ü¶Ñ'];
        let currentCharacterIndex = 0;

        function initGame() {
            currentWords = [...wordLevels[currentLevel]];
            shuffleArray(currentWords);
            updateCounter();
            updateLevelIndicator();
        }

        function updateLevelIndicator() {
            document.getElementById('levelNumber').textContent = currentLevel + 1;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startGame(withRecording) {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Sorry! Your browser doesn\'t support speech recognition. Please try Chrome, Edge, or Safari.');
                return;
            }

            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('startRecordBtn').style.display = 'none';
            document.getElementById('skipBtn').style.display = 'inline-block';
            document.getElementById('levelIndicator').style.display = 'block';

            initGame();
            pendingRecordingStart = withRecording;
            startSpeechRecognition();
            if (withRecording) {
                showRecordingControls();
            }
            showNextWord();
        }

        function startSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
            recognition = new SpeechRecognition();

            recognition.continuous = true;  // Keep listening
            recognition.interimResults = true;  // Get partial results
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 5;  // Get multiple interpretations

            // Additional settings for better sensitivity
            if ('audioCapture' in recognition) {
                recognition.audioCapture = true;
            }

            recognition.onstart = function() {
                isListening = true;
                document.getElementById('wordDisplay').classList.add('listening');
                updateStatus('üé§ I\'m listening! Say the word!');
                console.log('%cüéôÔ∏è Speech Recognition Started', 'color: green; font-weight: bold');
                if (pendingRecordingStart) {
                    pendingRecordingStart = false;
                    startRecording();
                }
            };

            // Audio detection events
            recognition.onaudiostart = function() {
                console.log('%cüîä Audio capture started', 'color: gray');
            };

            recognition.onaudioend = function() {
                console.log('%cüîá Audio capture ended', 'color: gray');
            };

            recognition.onsoundstart = function() {
                console.log('%cüì¢ Sound detected', 'color: purple');
            };

            recognition.onsoundend = function() {
                console.log('%cüîï Sound ended', 'color: purple');
            };

            recognition.onspeechstart = function() {
                console.log('%cüó£Ô∏è Speech detected (processing...)', 'color: blue; font-weight: bold');
            };

            recognition.onspeechend = function() {
                console.log('%cü§ê Speech ended', 'color: blue');
            };

            recognition.onnomatch = function(event) {
                console.log('%c‚ùì Speech detected but no match from recognition engine', 'color: orange; font-weight: bold');
            };

            recognition.onresult = function(event) {
                // Don't process if we're celebrating a correct word
                if (isProcessingWord) {
                    return;
                }

                const now = Date.now();
                const targetWord = currentWords[currentWordIndex].toLowerCase();

                // Reduced debounce for faster response to quiet speech
                if (now - lastRecognitionTime < 100) {
                    return;
                }

                let bestAttempt = null;

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const isFinal = result.isFinal;

                    // Check all alternatives for better matching
                    for (let j = 0; j < result.length; j++) {
                        const transcript = result[j].transcript.toLowerCase().trim();
                        const confidence = result[j].confidence || 1.0;

                        // Track attempt for debugging
                        const attempt = {
                            transcript: transcript,
                            confidence: confidence.toFixed(2),
                            isFinal: isFinal,
                            target: targetWord,
                            rejected: null,
                            matched: false
                        };

                        // Ignore completely empty
                        if (transcript.length < 1) {
                            attempt.rejected = 'empty';
                            debugAttempts.push(attempt);
                            continue;
                        }

                        // Smart noise filtering: check if it contains letters/words
                        const hasLetters = /[a-z]/i.test(transcript);
                        if (!hasLetters) {
                            attempt.rejected = 'no_letters';
                            debugAttempts.push(attempt);
                            continue;
                        }

                        // VERY sensitive confidence filtering - accept almost anything with words
                        // Only reject extremely low confidence to filter pure noise
                        if (confidence !== undefined) {
                            // For final results, extremely low threshold (0.1) - accept almost anything
                            if (isFinal && confidence < 0.1) {
                                attempt.rejected = `low_conf_final(${confidence.toFixed(2)})`;
                                debugAttempts.push(attempt);
                                continue;
                            }
                            // For interim results, low threshold (0.3) - still very accepting
                            if (!isFinal && confidence < 0.3) {
                                attempt.rejected = `low_conf_interim(${confidence.toFixed(2)})`;
                                debugAttempts.push(attempt);
                                continue;
                            }
                        }

                        // Track this as a valid attempt
                        if (!bestAttempt || confidence > parseFloat(bestAttempt.confidence)) {
                            bestAttempt = attempt;
                        }

                        if (isWordMatch(transcript, targetWord)) {
                            attempt.matched = true;
                            debugAttempts.push(attempt);

                            // Log successful match
                            console.log('%c‚úÖ MATCH FOUND', 'color: green; font-weight: bold; font-size: 14px', {
                                spoken: transcript,
                                target: targetWord,
                                confidence: confidence.toFixed(2),
                                isFinal: isFinal
                            });

                            lastRecognitionTime = now;
                            handleCorrectWord();

                            // Clear debug attempts after success
                            debugAttempts = [];
                            return;
                        } else {
                            attempt.rejected = 'no_match';
                            debugAttempts.push(attempt);
                        }
                    }
                }

                // Log if we got results but nothing processable
                if (bestAttempt === null && event.results.length > 0) {
                    console.log('%c‚ö†Ô∏è Got speech results but all were filtered out', 'color: orange', {
                        totalResults: event.results.length,
                        checkDebugAttempts: 'See debugAttempts array for details'
                    });
                }

                // Periodically log aggregated debug info (every 5 attempts)
                if (debugAttempts.length >= 5 && debugAttempts.length % 5 === 0) {
                    logDebugSummary();
                }
            };

            recognition.onerror = function(event) {
                // Log all errors for debugging
                const errorMessages = {
                    'no-speech': '‚è∏Ô∏è No speech detected (timeout)',
                    'audio-capture': 'üî¥ Audio capture failed',
                    'not-allowed': 'üö´ Microphone access denied',
                    'network': 'üåê Network error',
                    'aborted': '‚õî Recognition aborted',
                    'bad-grammar': 'üìù Grammar error',
                    'language-not-supported': 'üåç Language not supported'
                };

                const message = errorMessages[event.error] || `‚ùå Unknown error: ${event.error}`;
                console.log(`%c${message}`, 'color: red; font-weight: bold');

                if (event.error === 'not-allowed') {
                    updateStatus('Please allow microphone access!');
                }

                if (event.error === 'audio-capture' && isRecordingActive) {
                    updateStatus('Recording paused so I can keep listening.');
                    stopRecording();
                }

                // Don't spam console with no-speech errors
                if (event.error === 'no-speech') {
                    console.log('%cüí° TIP: Speak louder or closer to the microphone', 'color: orange');
                }
            };

            recognition.onend = function() {
                console.log('%c‚èπÔ∏è Recognition ended, restarting...', 'color: gray');

                // If we manually aborted to re-arm for a new word, skip auto restart
                if (manualRestartPending) {
                    manualRestartPending = false;
                    return;
                }

                // Automatically restart if game is still active
                if (isListening && currentWordIndex < currentWords.length) {
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.error('%c‚ùå Failed to restart recognition', 'color: red; font-weight: bold', e);
                        }
                    }, 100);
                }
            };
        }

        // Global debug helper - can be called from console
        window.checkSpeechDebug = function() {
            console.group('%cüîß Speech Recognition Debug Info', 'color: cyan; font-weight: bold; font-size: 16px');
            console.log('Current target:', currentWords[currentWordIndex]);
            console.log('Is listening:', isListening);
            console.log('Is processing word:', isProcessingWord);
            console.log('Total attempts logged:', debugAttempts.length);
            console.log('Recognition state:', recognition ? 'initialized' : 'not initialized');

            if (debugAttempts.length > 0) {
                console.log('\nüìä Recent attempts:');
                logDebugSummary();
            } else {
                console.log('%c‚ö†Ô∏è No attempts logged yet - speech may not be reaching the recognition engine', 'color: orange; font-weight: bold');
                console.log('Possible reasons:');
                console.log('  1. Volume too low');
                console.log('  2. Microphone not working');
                console.log('  3. Background noise drowning out speech');
                console.log('  4. Browser speech recognition internal filtering');
            }

            console.log('\nüí° TIP: Watch for these console messages when you speak:');
            console.log('  - üì¢ Sound detected (means microphone is picking up audio)');
            console.log('  - üó£Ô∏è Speech detected (means engine recognizes it as speech)');
            console.log('  - If you see neither, the audio is too quiet for the browser');

            console.groupEnd();
        };

        console.log('%cüí° Debug Helper Available: Type checkSpeechDebug() in console anytime', 'color: cyan; font-size: 12px');

        // Apply a tight grammar so the recognizer biases toward the current target
        function applyGrammarFor(target) {
            const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
            if (!recognition || !SpeechGrammarList) return;

            const grammars = new SpeechGrammarList();
            grammars.addFromString(`#JSGF V1.0; grammar words; public <word> = ${target};`, 1.0);
            recognition.grammars = grammars;
            // Ensure we keep a few alternatives while staying biased
            recognition.maxAlternatives = Math.max(recognition.maxAlternatives || 1, 3);
        }

        // Restart recognition for each new word so we get a fresh buffer with the new grammar
        function restartRecognitionForWord(target) {
            applyGrammarFor(target);
            if (!recognition) return;

            // If we haven't started listening yet, just start with the grammar applied
            if (!isListening) {
                try {
                    recognition.start();
                    console.log('%cüéØ Recognition armed for first word:', 'color: teal; font-weight: bold', target);
                } catch (e) {
                    console.error('Failed to start recognition for first word', target, e);
                }
                return;
            }

            manualRestartPending = true;
            try {
                recognition.abort();
            } catch (e) {
                console.warn('Recognition abort failed (may not be running yet):', e);
            }

            setTimeout(() => {
                try {
                    recognition.start();
                    console.log('%cüéØ Recognition re-armed for word:', 'color: teal; font-weight: bold', target);
                } catch (e) {
                    console.error('Failed to restart recognition for word', target, e);
                }
            }, 120);
        }

        function logDebugSummary() {
            const recentAttempts = debugAttempts.slice(-10);  // Last 10 attempts

            // Aggregate statistics
            const stats = {
                total: recentAttempts.length,
                byReason: {},
                avgConfidence: 0,
                transcripts: []
            };

            let confSum = 0;
            let confCount = 0;

            recentAttempts.forEach(att => {
                const reason = att.rejected || 'matched';
                stats.byReason[reason] = (stats.byReason[reason] || 0) + 1;

                if (att.confidence) {
                    confSum += parseFloat(att.confidence);
                    confCount++;
                }

                if (att.transcript && !stats.transcripts.includes(att.transcript)) {
                    stats.transcripts.push(att.transcript);
                }
            });

            stats.avgConfidence = confCount > 0 ? (confSum / confCount).toFixed(2) : 'N/A';

            // Log structured summary
            console.groupCollapsed(`üîç Speech Detection Summary (Target: "${recentAttempts[0]?.target}")`);
            console.log('%cAttempts:', 'font-weight: bold', stats.total);
            console.log('%cRejection reasons:', 'font-weight: bold', stats.byReason);
            console.log('%cAvg Confidence:', 'font-weight: bold', stats.avgConfidence);
            console.log('%cWhat was heard:', 'font-weight: bold', stats.transcripts);

            // Show detailed table
            console.table(recentAttempts.map(a => ({
                'Transcript': a.transcript,
                'Confidence': a.confidence,
                'Final': a.isFinal ? '‚úì' : '‚óã',
                'Status': a.matched ? '‚úÖ MATCH' : `‚ùå ${a.rejected}`
            })));

            console.groupEnd();
        }

        // Very lenient fuzzy matching using Levenshtein distance
        function isWordMatch(spoken, target) {
            spoken = spoken.toLowerCase().trim();
            target = target.toLowerCase().trim();

            // Exact match
            if (spoken === target) return true;

            // Check if spoken contains the full target phrase
            if (spoken.includes(target)) return true;

            // Split into words for phrase handling
            const targetWords = target.split(' ');
            const spokenWords = spoken.split(' ');

            // For multi-word targets (phrases), check all words are present
            if (targetWords.length > 1) {
                // Check if all target words are present in spoken text
                // Use word boundary matching to avoid partial matches
                const allWordsPresent = targetWords.every(targetWord => {
                    // Check if this target word matches any spoken word with fuzzy matching
                    return spokenWords.some(spokenWord => {
                        // Exact match
                        if (spokenWord === targetWord) return true;

                        // Fuzzy match for individual words (for mispronunciations)
                        const distance = levenshteinDistance(spokenWord, targetWord);
                        const maxLen = Math.max(spokenWord.length, targetWord.length);
                        const similarity = 1 - (distance / maxLen);

                        // More lenient similarity for individual words (60%)
                        return similarity >= 0.6;
                    });
                });

                if (!allWordsPresent) return false;

                // Light word order check - just verify words appear in roughly the right order
                // This is more forgiving than strict sequential checking
                let lastFoundIndex = -1;
                for (let targetWord of targetWords) {
                    let foundIndex = -1;
                    for (let i = 0; i < spokenWords.length; i++) {
                        const spokenWord = spokenWords[i];
                        let matches = false;

                        if (spokenWord === targetWord) {
                            matches = true;
                        } else {
                            // Check fuzzy match
                            const distance = levenshteinDistance(spokenWord, targetWord);
                            const maxLen = Math.max(spokenWord.length, targetWord.length);
                            const similarity = 1 - (distance / maxLen);
                            if (similarity >= 0.6) {
                                matches = true;
                            }
                        }

                        if (matches && i > lastFoundIndex) {
                            foundIndex = i;
                            break;
                        }
                    }
                    if (foundIndex === -1) return false;
                    lastFoundIndex = foundIndex;
                }

                return true;
            }

            // For single words, use lenient fuzzy matching
            // If spoken has extra words, check if target word is clearly present
            if (targetWords.length === 1 && spokenWords.length > 1) {
                // Check if the target word appears in the spoken words
                const targetInSpoken = spokenWords.some(spokenWord => {
                    if (spokenWord === target) return true;
                    const distance = levenshteinDistance(spokenWord, target);
                    const maxLen = Math.max(spokenWord.length, target.length);
                    const similarity = 1 - (distance / maxLen);
                    return similarity >= 0.7;  // Moderately lenient
                });
                if (targetInSpoken) return true;

                // Also try matching the whole spoken phrase against target with standard fuzzy matching
                const distance = levenshteinDistance(spoken, target);
                const maxLength = Math.max(spoken.length, target.length);
                const similarity = 1 - (distance / maxLength);
                return similarity >= 0.6;
            }

            // Standard fuzzy matching for single words
            const distance = levenshteinDistance(spoken, target);
            const maxLength = Math.max(spoken.length, target.length);
            const similarity = 1 - (distance / maxLength);

            // Very lenient: 60% similarity is enough
            return similarity >= 0.6;
        }

        // Levenshtein distance algorithm
        function levenshteinDistance(str1, str2) {
            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        function handleCorrectWord() {
            // Prevent processing another word during celebration
            isProcessingWord = true;

            score++;

            // Adaptive difficulty tracking
            consecutiveSuccesses++;
            consecutiveFailures = 0;  // Reset failure count

            // Visual feedback - add success glow
            const wordDisplay = document.getElementById('wordDisplay');
            wordDisplay.classList.remove('listening');
            wordDisplay.classList.add('success');
            setTimeout(() => wordDisplay.classList.remove('success'), 600);

            // Celebration!
            playSuccessSound();
            showConfetti();
            celebrateCharacter();
            showFeedbackMessage();

            // Check if we should level up based on performance
            let shouldLevelUp = false;
            if (consecutiveSuccesses >= SUCCESS_THRESHOLD && currentLevel < wordLevels.length - 1) {
                shouldLevelUp = true;
                consecutiveSuccesses = 0;  // Reset counter
            }

            setTimeout(() => {
                currentWordIndex++;

                if (currentWordIndex >= currentWords.length || shouldLevelUp) {
                    // Level complete or performance-based level up!
                    if (currentLevel < wordLevels.length - 1) {
                        currentLevel++;
                        currentWordIndex = 0;
                        initGame();
                        if (shouldLevelUp) {
                            updateStatus('üåü You\'re doing great! Let\'s try harder words!');
                        } else {
                            updateStatus('üéâ Level complete! Moving up!');
                        }
                        playLevelUpSound();
                        setTimeout(() => {
                            showNextWord();
                            isProcessingWord = false;  // Re-enable processing
                        }, 2000);
                    } else {
                        // Game complete!
                        endGame(true);
                    }
                } else {
                    showNextWord();
                    isProcessingWord = false;  // Re-enable processing
                }
            }, 1500);  // Reduced from 2000ms to make it feel snappier
        }

        function showNextWord() {
            if (currentWordIndex < currentWords.length) {
                const word = currentWords[currentWordIndex];
                document.getElementById('currentWord').textContent = word;
                adjustWordSizing();
                updateStatus('üé§ Say: "' + word + '"');
                updateCounter();
                rotateCharacter();

                // Re-arm recognition with a grammar biased to this word/phrase
                restartRecognitionForWord(word);

                // Log new word
                console.log('%cüéØ NEW WORD', 'color: blue; font-weight: bold; font-size: 14px', {
                    target: word,
                    level: currentLevel + 1,
                    progress: `${currentWordIndex + 1}/${currentWords.length}`
                });

                // Clear previous attempts
                debugAttempts = [];

                // Re-enable listening visual indicator
                const wordDisplay = document.getElementById('wordDisplay');
                wordDisplay.classList.remove('success');
                if (isListening) {
                    wordDisplay.classList.add('listening');
                }
            }
        }

        function adjustWordSizing() {
            const wordDisplay = document.getElementById('wordDisplay');
            const wordSpan = document.getElementById('currentWord');
            wordDisplay.classList.remove('multi-line', 'very-long');

            requestAnimationFrame(() => {
                const styles = window.getComputedStyle(wordSpan);
                let lineHeight = parseFloat(styles.lineHeight);
                if (Number.isNaN(lineHeight)) {
                    const fontSize = parseFloat(styles.fontSize) || 16;
                    lineHeight = fontSize * 1.2;
                }
                const height = wordSpan.getBoundingClientRect().height;
                const lines = Math.round(height / lineHeight);
                if (lines > 1) {
                    wordDisplay.classList.add('multi-line');
                }
                if (lines > 2) {
                    wordDisplay.classList.add('very-long');
                }
            });
        }

        function skipWord() {
            // Log debug summary before skipping
            if (debugAttempts.length > 0) {
                console.log('%c‚è≠Ô∏è WORD SKIPPED', 'color: orange; font-weight: bold; font-size: 14px', {
                    target: currentWords[currentWordIndex],
                    attempts: debugAttempts.length
                });
                logDebugSummary();
            }

            isProcessingWord = false;  // Reset in case we're skipping during celebration

            // Clear debug attempts for next word
            debugAttempts = [];

            // Adaptive difficulty tracking
            consecutiveFailures++;
            consecutiveSuccesses = 0;  // Reset success count

            // Check if we should level down to easier words
            if (consecutiveFailures >= FAILURE_THRESHOLD && currentLevel > 0) {
                currentLevel--;
                currentWordIndex = 0;
                consecutiveFailures = 0;  // Reset counter
                initGame();
                updateStatus('üíô Let\'s try some easier words!');
                playEncouragingSound();
                setTimeout(showNextWord, 1500);
            } else {
                currentWordIndex++;
                if (currentWordIndex >= currentWords.length) {
                    currentWordIndex = 0;
                }
                showNextWord();
                updateStatus('No worries! Let\'s try a different word!');
            }
        }

        function updateCounter() {
            const counter = document.getElementById('progressText');
            if (!counter || currentWords.length === 0) {
                return;
            }
            const completed = Math.min(currentWordIndex, currentWords.length);
            counter.textContent = `${completed}/${currentWords.length} done`;
        }

        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (!statusEl) {
                return;
            }
            statusEl.textContent = message;
        }

        function celebrateCharacter() {
            const char = document.getElementById('character');
            char.classList.remove('celebrate');
            setTimeout(() => char.classList.add('celebrate'), 10);
            setTimeout(() => char.classList.remove('celebrate'), 600);
        }

        function rotateCharacter() {
            currentCharacterIndex = (currentCharacterIndex + 1) % characters.length;
            document.getElementById('character').textContent = characters[currentCharacterIndex];
        }

        function showFeedbackMessage() {
            const messages = [
                'You did it!',
                'Super reader!',
                'Shiny star!',
                'Fantastic!',
                'Great job!',
                'High five!',
                'So proud of you!',
                'You are amazing!'
            ];
            const message = messages[Math.floor(Math.random() * messages.length)];
            const feedbackEl = document.getElementById('feedbackMessage');
            feedbackEl.textContent = message;
            feedbackEl.classList.remove('show');
            setTimeout(() => feedbackEl.classList.add('show'), 10);
            setTimeout(() => feedbackEl.classList.remove('show'), 1500);
        }

        // Confetti effect
        function showConfetti() {
            const canvas = document.getElementById('confetti');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const pieces = [];
            const colors = ['#FFD700', '#FF69B4', '#00CED1', '#FF6347', '#9370DB', '#3CB371'];

            // Fewer, gentler confetti pieces
            for (let i = 0; i < 50; i++) {
                pieces.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    rotation: Math.random() * 360,
                    speed: Math.random() * 2 + 1.5,  // Slower fall
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 4  // Slightly smaller
                });
            }

            function animateConfetti() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let piece of pieces) {
                    ctx.save();
                    ctx.translate(piece.x, piece.y);
                    ctx.rotate(piece.rotation * Math.PI / 180);
                    ctx.fillStyle = piece.color;
                    ctx.fillRect(-piece.size / 2, -piece.size / 2, piece.size, piece.size);
                    ctx.restore();

                    piece.y += piece.speed;
                    piece.rotation += 2;

                    if (piece.y > canvas.height) {
                        piece.y = -10;
                        piece.x = Math.random() * canvas.width;
                    }
                }
            }

            let frameCount = 0;
            const maxFrames = 30;  // Shorter duration
            const interval = setInterval(() => {
                animateConfetti();
                frameCount++;
                if (frameCount > maxFrames) {
                    clearInterval(interval);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    canvas.style.display = 'none';
                }
            }, 1000 / 30);
        }

        // Audio feedback - Milder, gentler sounds
        function playSuccessSound() {
            // Create a soft, gentle "ding" sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Softer, warmer tone
            oscillator.type = 'sine';  // Sine wave for softer sound
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);  // C note
            oscillator.frequency.exponentialRampToValueAtTime(659.25, audioContext.currentTime + 0.08);  // E note

            // Much lower volume (0.12 instead of 0.3)
            gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.25);
        }

        function playLevelUpSound() {
            // Gentle ascending tones
            const notes = [523.25, 659.25, 783.99]; // C, E, G
            notes.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine';  // Softer sine wave
                const startTime = audioContext.currentTime + (i * 0.12);
                oscillator.frequency.setValueAtTime(freq, startTime);

                // Lower volume
                gainNode.gain.setValueAtTime(0.15, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.25);

                oscillator.start(startTime);
                oscillator.stop(startTime + 0.25);
            });
        }

        function playEncouragingSound() {
            // Warm, encouraging descending tone
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);  // E note
            oscillator.frequency.exponentialRampToValueAtTime(523.25, audioContext.currentTime + 0.15);  // C note

            // Very gentle volume
            gainNode.gain.setValueAtTime(0.10, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        function endGame(completed) {
            isListening = false;
            if (recognition) {
                recognition.stop();
            }
            document.getElementById('wordDisplay').classList.remove('listening');

            if (completed) {
                document.getElementById('currentWord').textContent = 'üåü Super reader! üåü';
                adjustWordSizing();
                updateStatus('You did it! You completed all the words!');
                showConfetti();
                playLevelUpSound();
            }
            currentWordIndex = currentWords.length;
            updateCounter();

            document.getElementById('skipBtn').style.display = 'none';
            document.getElementById('restartBtn').style.display = 'inline-block';
        }

        function restartGame() {
            currentLevel = 0;
            currentWordIndex = 0;
            score = 0;
            isProcessingWord = false;
            consecutiveSuccesses = 0;
            consecutiveFailures = 0;
            pendingRecordingStart = false;
            document.getElementById('restartBtn').style.display = 'none';
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startRecordBtn').style.display = 'inline-block';
            document.getElementById('levelIndicator').style.display = 'none';
            document.getElementById('currentWord').textContent = 'Ready!';
            adjustWordSizing();
            hideRecordingControls();
            document.getElementById('progressText').textContent = '';
        }

        async function startRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                return;
            }

            try {
                if (!window.MediaRecorder) {
                    updateStatus('Recording is not supported in this browser.');
                    return;
                }
                if (!recordingStream) {
                    recordingStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(recordingStream);
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    if (downloadUrl) {
                        URL.revokeObjectURL(downloadUrl);
                    }
                    downloadUrl = URL.createObjectURL(blob);
                    const link = document.getElementById('downloadLink');
                    link.href = downloadUrl;
                    link.style.display = 'inline-block';
                };
                mediaRecorder.start();
                document.getElementById('recordDot').classList.add('recording');
                document.getElementById('stopRecordBtn').disabled = false;
                isRecordingActive = true;
            } catch (error) {
                alert('Microphone access is needed to record.');
            }
        }

        function stopRecording() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                return;
            }
            mediaRecorder.stop();
            document.getElementById('recordDot').classList.remove('recording');
            document.getElementById('stopRecordBtn').disabled = true;
            isRecordingActive = false;
        }

        function showRecordingControls() {
            const controls = document.querySelector('.record-controls');
            controls.style.display = 'flex';
            document.getElementById('downloadLink').style.display = 'none';
            document.getElementById('recordDot').classList.remove('recording');
            document.getElementById('stopRecordBtn').disabled = true;
        }

        function hideRecordingControls() {
            const controls = document.querySelector('.record-controls');
            controls.style.display = 'none';
            document.getElementById('downloadLink').style.display = 'none';
            document.getElementById('recordDot').classList.remove('recording');
            document.getElementById('stopRecordBtn').disabled = true;
        }
    </script>
</body>
</html>
