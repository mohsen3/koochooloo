<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Tracing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', cursive;
            background: linear-gradient(135deg, #e6f5ff 0%, #f0f8ff 50%, #fafcff 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* Background dots pattern */
        .dots-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(79, 163, 209, 0.15);
            border-radius: 50%;
        }

        .container {
            background: linear-gradient(135deg, #ffffff 0%, #fafcff 100%);
            border-radius: 30px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            text-align: center;
            max-width: 900px;
            width: 90%;
            position: relative;
            z-index: 1;
            border: 4px solid rgba(79, 163, 209, 0.2);
        }

        h1 {
            color: #4fa3d1;
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0px rgba(255,164,91,0.2);
            letter-spacing: 1px;
        }

        .instructions {
            font-size: 1em;
            color: #6bcf7f;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border: 3px solid rgba(79, 163, 209, 0.2);
        }

        canvas {
            display: block;
            border-radius: 15px;
            touch-action: none;
            cursor: crosshair;
        }

        .celebration-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: 900;
            z-index: 1000;
            animation: celebrate 1s ease-out;
            pointer-events: none;
            background: linear-gradient(135deg, #6bcf7f 0%, #4fa3d1 100%);
            padding: 30px 50px;
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 6px solid #ffffff;
            color: white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.2);
        }

        @keyframes celebrate {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.15) rotate(5deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confetti-fall 2s linear forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .shape-indicator {
            font-size: 1.2em;
            color: #4fa3d1;
            margin-top: 15px;
            font-weight: 600;
        }

        .score-info {
            font-size: 1.5em;
            background: linear-gradient(135deg, #ff6b9d, #ffa45b);
            color: white;
            margin: 15px auto 0 auto;
            font-weight: bold;
            padding: 10px 30px;
            border-radius: 50px;
            display: inline-block;
            box-shadow: 0 6px 15px rgba(255, 107, 157, 0.4);
            animation: scoreFloat 2s ease-in-out infinite;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        @keyframes scoreFloat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <!-- Background dots -->
    <div class="dots-background" id="dots-background"></div>

    <div class="container">
        <h1>✏️ Shape Tracing</h1>
        <div class="instructions">Trace the dotted shape!</div>

        <div class="canvas-container">
            <canvas id="canvas" width="600" height="400"></canvas>
        </div>

        <div class="shape-indicator" id="shape-indicator">Shape: Line</div>
        <div class="score-info" id="score-info">Score: 30</div>
    </div>

    <div class="celebration" id="celebration"></div>

    <script>
        class TracingGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.drawing = false;
                this.currentPath = [];
                this.drawnPaths = [];
                this.currentShapeIndex = 0;
                this.penLifted = true;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Difficulty scoring system
                this.difficultyScore = 30.0; // Internal floating point score (1-100)
                this.consecutiveSuccesses = 0;
                this.consecutiveFailures = 0;

                // Shape definitions (relative to canvas size)
                this.shapes = [
                    {
                        name: 'Line',
                        type: 'line',
                        points: [[150, 200], [450, 200]]
                    },
                    {
                        name: 'Diagonal Line',
                        type: 'line',
                        points: [[150, 300], [450, 100]]
                    },
                    {
                        name: 'Triangle',
                        type: 'polygon',
                        points: [[300, 100], [450, 300], [150, 300], [300, 100]]
                    },
                    {
                        name: 'Square',
                        type: 'polygon',
                        points: [[200, 150], [400, 150], [400, 350], [200, 350], [200, 150]]
                    },
                    {
                        name: 'Rectangle',
                        type: 'polygon',
                        points: [[150, 200], [450, 200], [450, 300], [150, 300], [150, 200]]
                    },
                    {
                        name: 'Cross',
                        type: 'multiline',
                        paths: [
                            [[300, 100], [300, 350]],
                            [[150, 225], [450, 225]]
                        ]
                    },
                    {
                        name: 'Star',
                        type: 'polygon',
                        points: this.generateStarPoints(300, 200, 5, 80, 40)
                    },
                    {
                        name: 'Circle',
                        type: 'circle',
                        center: [300, 200],
                        radius: 100
                    }
                ];

                this.init();
            }

            generateStarPoints(cx, cy, spikes, outerRadius, innerRadius) {
                const points = [];
                const step = Math.PI / spikes;

                for (let i = 0; i < 2 * spikes; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = i * step - Math.PI / 2;
                    points.push([
                        cx + radius * Math.cos(angle),
                        cy + radius * Math.sin(angle)
                    ]);
                }
                points.push(points[0]); // Close the shape
                return points;
            }

            init() {
                this.createBackgroundDots();
                this.setupEventListeners();
                this.drawCurrentShape();
                this.updateScoreDisplay();
            }

            createBackgroundDots() {
                const dotsContainer = document.getElementById('dots-background');
                const spacing = 30;

                for (let x = spacing; x < window.innerWidth; x += spacing) {
                    for (let y = spacing; y < window.innerHeight; y += spacing) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = x + 'px';
                        dot.style.top = y + 'px';
                        dotsContainer.appendChild(dot);
                    }
                }
            }

            setupEventListeners() {
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.startDrawing(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.draw(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.stopDrawing(e), { passive: false });

                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', (e) => this.stopDrawing(e));
                this.canvas.addEventListener('mouseleave', (e) => this.stopDrawing(e));
            }

            getCoordinates(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                if (e.touches) {
                    e.preventDefault();
                    return {
                        x: (e.touches[0].clientX - rect.left) * scaleX,
                        y: (e.touches[0].clientY - rect.top) * scaleY
                    };
                }
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            startDrawing(e) {
                this.drawing = true;
                this.penLifted = false;
                const coords = this.getCoordinates(e);
                this.currentPath = [coords];

                this.ctx.beginPath();
                this.ctx.moveTo(coords.x, coords.y);
            }

            draw(e) {
                if (!this.drawing) return;

                const coords = this.getCoordinates(e);
                this.currentPath.push(coords);

                this.ctx.lineTo(coords.x, coords.y);
                this.ctx.strokeStyle = '#4fa3d1';
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.stroke();
            }

            stopDrawing(e) {
                if (!this.drawing) return;

                this.drawing = false;
                this.penLifted = true;

                if (this.currentPath.length > 0) {
                    this.drawnPaths.push([...this.currentPath]);
                    this.currentPath = [];
                }

                // Check if tracing is valid
                if (this.isTracingValid()) {
                    this.onSuccess();
                    this.celebrate();
                    setTimeout(() => {
                        this.nextShape();
                    }, 1500);
                } else if (this.isCanvasTooMessy()) {
                    // Failed attempt - canvas is too messy
                    this.onFailure();
                    // Clear canvas if too messy and pen is lifted
                    setTimeout(() => {
                        if (this.penLifted) {
                            this.clearCanvas();
                        }
                    }, 100);
                }
            }

            drawCurrentShape() {
                const shape = this.shapes[this.currentShapeIndex];
                document.getElementById('shape-indicator').textContent = `Shape: ${shape.name}`;

                this.ctx.save();
                this.ctx.setLineDash([10, 10]);
                this.ctx.strokeStyle = 'rgba(79, 163, 209, 0.4)';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                if (shape.type === 'circle') {
                    this.ctx.beginPath();
                    this.ctx.arc(shape.center[0], shape.center[1], shape.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else if (shape.type === 'multiline') {
                    shape.paths.forEach(path => {
                        this.ctx.beginPath();
                        this.ctx.moveTo(path[0][0], path[0][1]);
                        for (let i = 1; i < path.length; i++) {
                            this.ctx.lineTo(path[i][0], path[i][1]);
                        }
                        this.ctx.stroke();
                    });
                } else {
                    this.ctx.beginPath();
                    this.ctx.moveTo(shape.points[0][0], shape.points[0][1]);
                    for (let i = 1; i < shape.points.length; i++) {
                        this.ctx.lineTo(shape.points[i][0], shape.points[i][1]);
                    }
                    this.ctx.stroke();
                }

                this.ctx.restore();
            }

            isTracingValid() {
                const shape = this.shapes[this.currentShapeIndex];

                // Dynamic tolerance based on difficulty score
                // Score 1-10: 50px tolerance (very easy)
                // Score 30: 35px tolerance (easy, starting point)
                // Score 50: 25px tolerance (medium)
                // Score 70: 18px tolerance (hard)
                // Score 100: 10px tolerance (very hard)
                const threshold = 50 - (this.difficultyScore / 100) * 40;

                // Flatten all shape points
                let shapePoints = [];
                if (shape.type === 'circle') {
                    // Sample points on circle
                    const numSamples = 50;
                    for (let i = 0; i < numSamples; i++) {
                        const angle = (i / numSamples) * Math.PI * 2;
                        shapePoints.push({
                            x: shape.center[0] + shape.radius * Math.cos(angle),
                            y: shape.center[1] + shape.radius * Math.sin(angle)
                        });
                    }
                } else if (shape.type === 'multiline') {
                    shape.paths.forEach(path => {
                        path.forEach(point => shapePoints.push({ x: point[0], y: point[1] }));
                    });
                } else {
                    shape.points.forEach(point => shapePoints.push({ x: point[0], y: point[1] }));
                }

                // Count how many shape points are covered by drawn paths
                let coveredPoints = 0;
                shapePoints.forEach(sp => {
                    const isCovered = this.drawnPaths.some(path => {
                        return path.some(dp => {
                            const dist = Math.sqrt(Math.pow(sp.x - dp.x, 2) + Math.pow(sp.y - dp.y, 2));
                            return dist < threshold;
                        });
                    });
                    if (isCovered) coveredPoints++;
                });

                const coverage = coveredPoints / shapePoints.length;

                // Dynamic coverage requirement based on difficulty
                // Score 1-30: 65% coverage required (easier)
                // Score 50: 72% coverage required
                // Score 100: 80% coverage required (harder)
                const requiredCoverage = 0.65 + (this.difficultyScore / 100) * 0.15;

                return coverage > requiredCoverage;
            }

            isCanvasTooMessy() {
                // Count total drawn points
                let totalPoints = 0;
                this.drawnPaths.forEach(path => {
                    totalPoints += path.length;
                });

                // Consider messy if more than 300 points drawn
                return totalPoints > 300;
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawnPaths = [];
                this.drawCurrentShape();
            }

            nextShape() {
                this.currentShapeIndex = (this.currentShapeIndex + 1) % this.shapes.length;
                this.clearCanvas();
            }

            playCelebrationSound() {
                const now = this.audioContext.currentTime;
                const frequencies = [523.25, 659.25, 783.99];

                frequencies.forEach((freq, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';

                    const startTime = now + index * 0.1;
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + 0.3);
                });
            }

            celebrate() {
                this.playCelebrationSound();

                const messages = ["Perfect! ✨", "Great job! ⭐", "Amazing! 🎉", "Wonderful! 🌟"];
                const msg = messages[Math.floor(Math.random() * messages.length)];

                const celebration = document.createElement('div');
                celebration.className = 'celebration-overlay';
                celebration.textContent = msg;
                document.body.appendChild(celebration);

                setTimeout(() => {
                    celebration.remove();
                }, 1500);

                this.createConfetti();

                const container = document.querySelector('.container');
                container.classList.add('pulse');
                setTimeout(() => {
                    container.classList.remove('pulse');
                }, 500);
            }

            createConfetti() {
                const celebration = document.getElementById('celebration');
                const colors = ['#4fa3d1', '#6bcf7f', '#ffa45b', '#ff6b9d', '#ffd93d'];

                for (let i = 0; i < 40; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.3 + 's';
                    celebration.appendChild(confetti);

                    setTimeout(() => {
                        confetti.remove();
                    }, 2000);
                }
            }

            onSuccess() {
                // Increase difficulty when kid succeeds
                this.consecutiveSuccesses++;
                this.consecutiveFailures = 0;

                // Increase score based on consecutive successes
                // First success: +2 points
                // Second consecutive: +3 points
                // Third+ consecutive: +4 points
                let increment = 2;
                if (this.consecutiveSuccesses >= 3) {
                    increment = 4;
                } else if (this.consecutiveSuccesses >= 2) {
                    increment = 3;
                }

                this.difficultyScore = Math.min(100, this.difficultyScore + increment);
                this.updateScoreDisplay();
            }

            onFailure() {
                // Decrease difficulty when kid fails
                this.consecutiveFailures++;
                this.consecutiveSuccesses = 0;

                // Decrease score based on consecutive failures
                // First failure: -3 points
                // Second consecutive: -4 points
                // Third+ consecutive: -5 points
                let decrement = 3;
                if (this.consecutiveFailures >= 3) {
                    decrement = 5;
                } else if (this.consecutiveFailures >= 2) {
                    decrement = 4;
                }

                this.difficultyScore = Math.max(1, this.difficultyScore - decrement);
                this.updateScoreDisplay();
            }

            updateScoreDisplay() {
                const scoreInfo = document.getElementById('score-info');
                const displayScore = Math.round(this.difficultyScore);
                scoreInfo.textContent = `Score: ${displayScore}`;

                // Update color based on difficulty level
                if (displayScore >= 70) {
                    scoreInfo.style.background = 'linear-gradient(135deg, #c44569, #ff6b9d)';
                    scoreInfo.style.boxShadow = '0 6px 15px rgba(196, 69, 105, 0.4)';
                } else if (displayScore >= 50) {
                    scoreInfo.style.background = 'linear-gradient(135deg, #ffa45b, #ffd93d)';
                    scoreInfo.style.boxShadow = '0 6px 15px rgba(255, 164, 91, 0.4)';
                } else {
                    scoreInfo.style.background = 'linear-gradient(135deg, #ff6b9d, #ffa45b)';
                    scoreInfo.style.boxShadow = '0 6px 15px rgba(255, 107, 157, 0.4)';
                }
            }
        }

        window.addEventListener('load', () => {
            new TracingGame();
        });
    </script>
</body>
</html>
